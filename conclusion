1.模型搭建
    将前端页面进行处理（挖坑）
    根据具体需求进行填坑
    编写views视图函数
    配置url信息
2.数据库搭建
    继承父类方法，重写新的字段，实现用户的注册于验证
3.撰写用户注册页面的图形验证码与短信验证码
    1、ImgeCode类方法调用第三方库可以无限的产生随机4位图形验证码，同时从前端JS文件获取到image_code_id
       image_code_id 是用uuid方法产生的一串不重复的字符串，将产生的图形验证码和uuid同时存进数据库中
       并将图片返回给页面展示
    2、CheckUsernameView类方法是将用户填写的用户名（username）与数据进行对比，并将结果返回给前端JS页面
       如果数据库中存在则count==1，表示存在，如果不存在count==0，返回结果以字典的形式返回
    3、CheckMobileView类方法确认用户填写的手机号（mobile），功能同上
    4、SmsCodesView类方法获取短信验证码，在前面手机号确认ok的基础上进行短信验证，首先post方法获取到
       到前端页面的body内的内容（mobile，image_code_id，text）
       首先将获取到的json数据转成字典数据，并传给自定义的forms模块进行信息校验
       forms模块中定义需要校验的字段，然后继承父类中的clean方法，并将定义的字段用clean方法中的进行校验
       clean返回的是字典类型数据；连接数据库，将从前端得到的数据与数据库中存储的数据进行对比，如果数据
       一致，则自定义生成一段短信验证码的标记符，有标记符与手机号组成，为了方便查找与对比。最后存入数据库
    5、从forms模块返回的校验结果进行判断
        1、接口文件定义的代表返回OK, 如果返回-1， 就代表失败
        2、ok，则定义一个产生6位随机数的短信验证码，创建60s内发送过短信的记录标签与短信存储key，将两者存入
           数据库并通知平台发送短信
        3、如果校验ng则返回前端错误代码与信息
        4、短信发送平台需调用CCP().send_template_sms（）方法，参数为短信内容，存活时间，与模板编号
           返回结果result如果为0则发送短信成功else 则失败
4.用户注册数据验证：
    1、用户将信息填入表单后，接口文件将数据返回后端（username, password, mobile, sms_code等)，有后台进行数据验证，
    2、数据验证由forms模块完成，forms模块中定义了注册信息清洗功能类，继承父类的数据清洗，定义需要清洗的
       数据字段，并与数据库存储信息进行对比
    3、如果数据库中存在用户名则返回异常信息，并提示‘用户已注册’，手机号同理
    4、判断短信验证码是否正确
    5、图片验证码验证由verifications APP中的forms模块完成，原理同上，并实时返回给前端页面显示
    6、如信息全部ok则在数据库中创建新的数据
5.用户登录：
    1、用户信息验证，获取前端用户输入的数据（json格式，需转换）并与数据库信息进行比对，原理与注册验证相同，验证成功过后
       为用户信息添加session信息
    2、信息比对成功并成功添加session信息后，返回接口文件登录成功，并进行页面跳转
    3、在utils中创建middleware.py文件，并自定义一个csrf token中间键，并在settings文件中进行配置，
6.用户登出：
    调用logout方法，进行退出登录，logout方法会自动删除session信息。
7.新闻标签、新闻列表、新闻详情、新闻搜索实现
    1、分析各个模型所需的字段，并把公共重复字段重构，创建数据库模型并产生数据库迁移
    2、新闻标签：在index页面中展示且路由相同，故可以写在index类内，tag的查询：需要查询tag的id和name，所以用only方法只
       显示id和name并筛选没有逻辑删除的所有数据。热门新闻标签同理。最后将参数传给前端
    3、新闻列表：
        1）获取参数：从前端传过来的参数（tag_id page）, 对参数进行校验，校验ok后从数据库获取数据
        2）数据查询：根据参数在News数据库中查询title image_url update_time author_username tag_name digest等数据
        3）分页设置：新闻列表页码的查询调用内置方法Paginator，将需要分页的数据传入，并给定默认页数
        4）分页设置：判断前端传过来的页码是否符合规则（是否为整数，是否大于最大页码数等）
        5）数据序列化：将数据进行序列化并存入列表中
        6）返回前端：将分页信息与数据列表进行JSON转换并传回前端
    4、新闻详情:
        1）获取参数：news_id
        2）校验参数：从News数据库中查询news_id对应的 title content author tag_name update_time,并进行筛选
        3）判断数据：判断数据是否存在，如果不存在则返回not found
        4）评论查询：如果数据存在，则根据news_id查询新闻的评论
        5）评论序列化：将评论进行序列化并转成json
        6）返回前端：将数据渲染到html后展示给用户
    5、新闻评论：
        1）用户判断：判断用户是否登录，调用内置方法 is_authenticated
        2）添加子评论字段：在Comment数据库中添加parent字段并添加parent字段回调函数，并进行数据库迁移
        3）数据查询：根据前端传回的news_id进行数据查询，查询是否有此新闻
        4）添加评论：获取页面的body标签内的参数，将参数转成dict类型
                     获取到js发送过来的content参数（评论内容）同时获取到子评论id（如果有）
                     判断子评论id所关联的评论id是否正确
        5)数据存储：将新增品论存入数据库
    6、轮播图：
        1）获取参数：在Banner数据库中查询image_url news__title news__id 字段
        2）数据序列化：将数据进行序列化成列表
        3）传递参数：将参数json化后渲染到页面
    7、新闻搜索：
        1）准备：安装docker镜像与elasticsearch生成索引。对其进行相应配置（ip等）
        2）配置模板文件路径：继承SearchView类，配置template路径
        3）判断是否查询：重写响应（create_response），获取查询内容的键与值，
                         如果没有值（没有进行查询）则全展示，定义标签show_all，并查询所有热门新闻按时间与优先级排序展示
                         设置分页，并判断前端传递的页码是否为整数、是否存在
                         将数据返回
        4）返回查询结果：如果前端有查询数据，则继承父类，并返回


